{
  "version": "1.14.0",
  "compound": {
    "kind": "page",
    "id": "indexpage",
    "name": "SensorModbusMaster",
    "url_base": "index",
    "url": "index.html",
    "include": null,
    "has_template_details": false,
    "templates": null,
    "brief": "",
    "description": "<p><a name=\"mainpage\"></a></p><p>This library is designed to use an Arduino as a Modbus master to communicate with a sensor/slave via the <a href=\"https://en.wikipedia.org/wiki/Modbus\">Modbus RTU</a> communication protocol. It&#x27;s specifically written with lots of &quot;higher-level&quot; functions to help out users who are largely unfamiliar with the Modbus protocol and want an easy way to get information from a Modbus device.</p><hr/><section id=\"readme_using-the-library\"><h2>Using the library</h2><p>To communicate with a Modbus sensor or other Modbus slave, first create a stream instance (ie, Serial1, SoftwareSerial, AltSoftSerial) and then an instance of the <a href=\"classmodbus_master.html\" class=\"m-doc\">modbusMaster</a>.</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span><span class=\"c1\">// Create the stream instance</span></div>\n<div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span><span class=\"n\">HardwareSerial</span><span class=\"w\"> </span><span class=\"n\">modbusSerial</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Serial1</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// ALWAYS use HardwareSerial if it&#39;s an option</span></div>\n<div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span><span class=\"c1\">// OR</span></div>\n<div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\">4</span><span class=\"c1\">// AltSoftSerial modbusSerial;  // AltSoftSerial should be your second choice, if your board is supported</span></div>\n<div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\">5</span><span class=\"c1\">// OR</span></div>\n<div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\">6</span><span class=\"c1\">// SoftwareSerial modbusSerial(txPin, rxPin);  // SoftwareSerial should be your last choice.</span></div>\n<div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\">7</span></div>\n<div class=\"line\"><a id=\"l-8\" name=\"l-8\"></a><span class=\"linenos\">8</span><span class=\"c1\">// Create the modbus instance</span></div>\n<div class=\"line\"><a id=\"l-9\" name=\"l-9\"></a><span class=\"linenos\">9</span><span class=\"n\">modbusMaster</span><span class=\"w\"> </span><span class=\"n\">modbus</span><span class=\"p\">;</span>\n</div></div></div><p>Within the setup function begin both the serial instance and the <a href=\"classmodbus_master.html\" class=\"m-doc\">modbusMaster</a> instance. The enable pin allows you to use an RS485 to TTL adapter that is half-duplex with a pin that enables data sending.</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span><span class=\"c1\">// Start the stream</span></div>\n<div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span><span class=\"n\">modbusSerial</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"n\">baudRate</span><span class=\"p\">);</span></div>\n<div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span></div>\n<div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\">4</span><span class=\"c1\">// start the modbus</span></div>\n<div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\">5</span><span class=\"n\">modbus</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"n\">modbusSlaveID</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">modbusSerial</span><span class=\"p\">);</span></div>\n<div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\">6</span><span class=\"c1\">// ^^ use this if you have an RS485 adapter with automatic flow control</span></div>\n<div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\">7</span><span class=\"c1\">// modbus.begin(modbusSlaveID, modbusSerial, enablePin);</span></div>\n<div class=\"line\"><a id=\"l-8\" name=\"l-8\"></a><span class=\"linenos\">8</span><span class=\"c1\">// ^^ use this if you need to manually control flow direction on your RS485 adapter</span>\n</div></div></div><p>Once you&#x27;ve created and begun these, getting data from or adding data to a register is very simple:</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\"> 1</span><span class=\"c1\">// Retrieve data from a read-only input register</span></div>\n<div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\"> 2</span><span class=\"c1\">// Input registers are called with 0x04 - Input registers are always read-only</span></div>\n<div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\"> 3</span><span class=\"c1\">// This gets a 32-bit big endian float from input register 15</span></div>\n<div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\"> 4</span><span class=\"n\">modbus</span><span class=\"p\">.</span><span class=\"n\">float32FromRegister</span><span class=\"p\">(</span><span class=\"mh\">0x04</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bigEndian</span><span class=\"p\">);</span></div>\n<div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\"> 5</span></div>\n<div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\"> 6</span><span class=\"c1\">// Retrieve data from a read/write holding register</span></div>\n<div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\"> 7</span><span class=\"c1\">// Holding registers are called with 0x03</span></div>\n<div class=\"line\"><a id=\"l-8\" name=\"l-8\"></a><span class=\"linenos\"> 8</span><span class=\"c1\">// Retrieve a signed 16-big endian float from holding register 12</span></div>\n<div class=\"line\"><a id=\"l-9\" name=\"l-9\"></a><span class=\"linenos\"> 9</span><span class=\"n\">modbus</span><span class=\"p\">.</span><span class=\"n\">int16FromRegister</span><span class=\"p\">(</span><span class=\"mh\">0x03</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">littleEndian</span><span class=\"p\">);</span></div>\n<div class=\"line\"><a id=\"l-10\" name=\"l-10\"></a><span class=\"linenos\">10</span></div>\n<div class=\"line\"><a id=\"l-11\" name=\"l-11\"></a><span class=\"linenos\">11</span><span class=\"c1\">// Write the value &quot;56&quot; to holding register 20 as a little-endian unsigned 16-bit integer</span></div>\n<div class=\"line\"><a id=\"l-12\" name=\"l-12\"></a><span class=\"linenos\">12</span><span class=\"n\">modbus</span><span class=\"p\">.</span><span class=\"n\">uint16ToRegister</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">56</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">littleEndian</span><span class=\"p\">);</span>\n</div></div></div><hr/></section><section id=\"readme_modbus-maps\"><h2>Modbus Maps</h2><p>While Modbus RTU specifications define the format of a data frame and a very simple data structure for a master and slave, there are no specification for what types of data a slave stores, where it is stored, or in what format it is stored. You <strong>MUST</strong> get this information from the manufacturer/programmer of your Modbus device. Typically this information is shared in what is called a Modbus map.</p><p>You need the following data from your Modbus map:</p><ul><li>the baud rate the device communicates at (Modbus allows any baud rate)</li><li>the parity the device uses on the serial line (Modbus technically allows 8O1, 8E1, and 8N2, though some devices may use 8N1)<ul><li>Software serial libraries generally do not support 8O1, 8E1, or 8N2; you will need a hardware serial port available if your device uses one of these stop/parity configurations</li></ul></li><li>the type of register or coils the data you are interested is stored in (ie, holding register, input register, coil, or discrete input)<ul><li>Note - This library does not currently support getting or setting values in coils.</li><li>All input registers are read-only. If your map says a register is read/write (R/W), it is a holding register.</li></ul></li><li>the register or coil number the data is stored in</li><li>the format of data within the registers/coils (ie, float, integer, bit mask, ascii text)</li><li>whether multi-register numeric data is stored as <a href=\"https://en.wikipedia.org/wiki/Endianness\">&quot;big-endian&quot; or &quot;little-endian&quot;</a> values (That is, is it high <em>word</em> first or low <em>word</em> first. There are no specifications for this.)</li><li>whether single-register data is stored &quot;big-endian&quot; or &quot;little-endian&quot; (That is, is it high <em>byte</em> first or low <em>byte</em> first. Modbus specifies that it should be high byte first (big-endian), but devices vary.)<ul><li>Note - This library only supports data that is &quot;fully&quot; big or little endian. That is, data must be both high byte and high word first or both low byte and low word first. Mixed endianness is not supported.</li></ul></li></ul><p>Without this information, you have little hope of being able to communicate properly with the device. You can use programs like <a href=\"http://www.chipkin.com/cas-modbus-scanner/\">CAS Modbus scanner</a> to find a device if its address, baud rate, and parity are unknown, but it may take some time to make a connection. You can also use the &quot;scanRegisters&quot; utility in this library to get a view of all the registers, but if you don&#x27;t have a pretty good idea of what you are looking for that will not be as helpful as you might hope.</p><hr/></section><section id=\"readme_supported-data-types\"><h2>Supported Data Types</h2><p>The following data types are supported:</p><ul><li><code>uint16</code> (16-bit unsigned integer)<ul><li>Value must be within a single 16-bit register</li><li>bigEndian or littleEndian can be specified, bigEndian will be used by default</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06). Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li><li><code>int16</code> (16-bit signed integer)<ul><li>Value must be within a single 16-bit register</li><li>bigEndian or littleEndian can be specified, bigEndian will be used by default</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06). Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li><li><code>float32</code> (32-bit float)<ul><li>Value must be in two adjacent 16-bit registers</li><li>bigEndian or littleEndian can be specified, bigEndian will be used by default</li><li>Only &quot;fully&quot; big or little endianness is supported - that is both high byte and high word first or both low byte and low word first.</li></ul></li><li><code>uint32</code> (32-bit unsigned integer)<ul><li>Value must be in two adjacent 16-bit registers</li><li>bigEndian or littleEndian can be specified, bigEndian will be used by default</li><li>Only &quot;fully&quot; big or little endianness is supported - that is both high byte and high word first or both low byte and low word first.</li></ul></li><li><code>int32</code> (32-bit signed integer)<ul><li>Value must be in two adjacent 16-bit registers</li><li>bigEndian or littleEndian can be specified, bigEndian will be used by default</li><li>Only &quot;fully&quot; big or little endianness is supported - that is both high byte and high word first or both low byte and low word first.</li></ul></li><li><strong>TAI64</strong> (64-bit timestamp)<ul><li>Value must be in four contiguous 16-bit registers</li><li>Value is always fully big endian</li><li>Supported as if it were a 32-bit unix timestamp because the first 32-bits of the TAI64 timestamp will be 0x40000000 until the year 2106.</li><li>See <a href=\"https://www.tai64.com/\">https:/<wbr />/<wbr />www.tai64.com/<wbr /></a> for more details on this format type</li></ul></li><li><strong>TAI64N</strong> (64-bit timestamp followed by a 32-bit nanosecond count)<ul><li>Value must be in six contiguous 16-bit registers</li><li>Value is always fully big endian</li><li>Note that the seconds and nanoseconds are broken into two different fields.</li><li>See <a href=\"https://www.tai64.com/\">https:/<wbr />/<wbr />www.tai64.com/<wbr /></a> for more details on this format type</li></ul></li><li><strong>TAI64NA</strong> (64-bit timestamp followed by a 32-bit nanosecond count and then a 32-bit attosecond count)<ul><li>Value must be in eight contiguous 16-bit registers</li><li>Value is always fully big endian</li><li>Note that the seconds, nanoseconds, and attoseconds are broken into three different fields.</li><li>See <a href=\"https://www.tai64.com/\">https:/<wbr />/<wbr />www.tai64.com/<wbr /></a> for more details on this format type</li></ul></li><li><code>byte</code> (8-bit unsigned integer or raw byte of data)<ul><li>Must specify either the first or second 8-bit component of a single 16-bit register)</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06). Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li><li><code>char</code> (c++/ASCII style characters)<ul><li>Characters can be in one or more contiguous 16-bit registers</li><li>Length of the character array must be specified</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06) if the character array has two or fewer characters. Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li><li><code>String</code> (Arduino Strings)<ul><li>Characters can be in one or more contiguous 16-bit registers</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06) if the String has two or fewer characters. Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li><li><strong>pointer</strong> (pointers to other registers)<ul><li>Value must be within a single 16-bit register</li><li>By default, the Modbus command for pre-setting a single register will be used (0x06). Set the forceMultiple boolean flag to &#x27;true&#x27; to force the use of the Modbus command for setting multiple resisters (0x10).</li></ul></li></ul><p>There are also mid-level functions available to help to reduce serial traffic by calling many registers at once and low level functions to make raw Modbus calls. See <a href=\"_sensor_modbus_master_8h.html\" class=\"m-doc\">SensorModbusMaster.h</a> for all the available functions and their required and optional inputs</p><hr/></section><section id=\"readme_notes-on-ttl-and-rs485rs322-electrical-communications-standards\"><h2>Notes on TTL and RS485/RS322 electrical communications standards</h2><p>While Modbus RTU specifications define the format of a data frame transferred over a serial line, the type of serial signal is not defined. Many Modbus sensors communicate over <a href=\"https://en.wikipedia.org/wiki/RS-485\">RS-485</a>. To interface between RS485 and the TTL used by standard Arduino-type boards, you will need an RS485-to-TTL adapter. There are a number of RS485-to-TTL adapters available. When shopping for one, be mindful of the logic level of the TTL output by the adapter. The MAX485, one of the most popular adapters, has a 5V logic level in the TTL signal. This will <em>fry</em> any board that can only use on 3.3V logic. You would need a voltage shifter in between the Mayfly and the MAX485 to make it work. Also note that most RS485-to-TTL adapters are implemented <em>without</em> automatic flow control. That is, you must manually set voltages on driver enable and receiver enable pins to control the data flow direction. While this library includes functions for setting the enables, I&#x27;ve found commutation to be much more stable on adapters with built-in flow control. You will also need a <a href=\"#readme_hardware-interface-suggestions-for-envirodiy-mayfly\" class=\"m-doc\">hardware interface board</a> to communicate between an Arduino and any Modbus sensor that communicates over <a href=\"https://en.wikipedia.org/wiki/RS-422\">RS422</a> or <a href=\"https://en.wikipedia.org/wiki/RS-232\">RS232</a>. Again, mind your voltages and the method of direction control.</p></section><section id=\"readme_hardware-interface-suggestions-for-envirodiy-mayfly\"><h2>Hardware interface suggestions for EnviroDIY Mayfly</h2><p>For use with the <a href=\"https://github.com/EnviroDIY/EnviroDIY_Mayfly_Logger\">EnviroDIY Mayfly data logger</a> and other Arduino framework boards, you will likely need some additional <a href=\"https://github.com/EnviroDIY/SensorModbusMaster/tree/master/hardware\">Hardware for using ModbusRTU with RS-485 on Arduino</a>.</p><p>We have developed a <a href=\"https://github.com/EnviroDIY/SensorModbusMaster/tree/master/hardware/Modbus-Mayfly_WingShield\">Modbus-Mayfly-WingShield</a> that combines AltSoftSerial TTL to RS-485 conversion with an optional power boost to 9V or 12V. This has worked quite well for us for a variety of deployment configurations and sensors.</p></section>",
    "sections": [
      [
        "readme_using-the-library",
        "Using the library",
        []
      ],
      [
        "readme_modbus-maps",
        "Modbus Maps",
        []
      ],
      [
        "readme_supported-data-types",
        "Supported Data Types",
        []
      ],
      [
        "readme_notes-on-ttl-and-rs485rs322-electrical-communications-standards",
        "Notes on TTL and RS485/RS322 electrical communications standards",
        []
      ],
      [
        "readme_hardware-interface-suggestions-for-envirodiy-mayfly",
        "Hardware interface suggestions for EnviroDIY Mayfly",
        []
      ]
    ],
    "deprecated": null,
    "since": null,
    "example_navigation": null,
    "footer_navigation": null,
    "topics": [],
    "dirs": [],
    "files": [],
    "namespaces": [],
    "classes": [],
    "base_classes": [],
    "derived_classes": [],
    "enums": [],
    "typedefs": [],
    "funcs": [],
    "vars": [],
    "defines": [],
    "public_types": [],
    "public_static_funcs": [],
    "typeless_funcs": [],
    "public_funcs": [],
    "signals": [],
    "public_slots": [],
    "public_static_vars": [],
    "public_vars": [],
    "protected_types": [],
    "protected_static_funcs": [],
    "protected_funcs": [],
    "protected_slots": [],
    "protected_static_vars": [],
    "protected_vars": [],
    "private_funcs": [],
    "private_slots": [],
    "related": [],
    "friend_funcs": [],
    "groups": [],
    "has_enum_details": false,
    "has_typedef_details": false,
    "has_func_details": false,
    "has_var_details": false,
    "has_define_details": false,
    "breadcrumb": [
      [
        "SensorModbusMaster",
        "index.html"
      ]
    ],
    "breadcrumbGroup": [
      [
        "SensorModbusMaster",
        "index.html"
      ]
    ]
  }
}